# generated by fastapi-codegen:
#   filename:  openapi.json
#   timestamp: 2025-05-02T05:12:50+00:00

from __future__ import annotations

from typing import Annotated, Optional
from uuid import UUID
import importlib.metadata

from argon2 import PasswordHasher, Type
from argon2.exceptions import VerifyMismatchError
from fastapi import Depends, FastAPI, status, HTTPException
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from pydantic import BaseModel, Field

from buttercup.orchestrator.task_server.models.types import Status, Task, SARIFBroadcast, StatusState
from buttercup.orchestrator.task_server.backend import (
    delete_task,
    new_task,
    delete_all_tasks,
    store_sarif_broadcast,
    get_status_tasks_state,
)
from buttercup.common.logger import setup_package_logger
from buttercup.orchestrator.task_server.dependencies import (
    get_delete_task_queue,
    get_task_queue,
    get_settings,
    get_sarif_store,
)
from buttercup.orchestrator.task_server.config import TaskServerSettings
from buttercup.common.queues import ReliableQueue
from buttercup.common.sarif_store import SARIFStore
from urllib3.exceptions import MaxRetryError, NewConnectionError

settings = get_settings()
logger = setup_package_logger("task-server", __name__, settings.log_level, settings.log_max_line_length)
logger.info("Redis URL: %s", settings.redis_url)
logger.info("API Key ID: %s", settings.api_key_id)

try:
    __version__ = importlib.metadata.version("orchestrator")
except importlib.metadata.PackageNotFoundError:
    __version__ = "0.0.0"

app = FastAPI(
    title="Buttercup CRS API",
    contact={},
    version=__version__,
    servers=[{"url": "/"}],
    log_config=None,
)

# The exposed endpoints must be authenticated using HTTP Basic.
# Credentials will be composed of an API key and token which will be used as the username
# and password in HTTP Basic Auth.
# API keys will be UUIds, tokens will be random alphanumeric strings of at least 32 chars.
# Tokens are stored using Argon2ID.
security = HTTPBasic()

# Create password hasher with Argon2id
ph = PasswordHasher(
    time_cost=3,  # Number of iterations
    memory_cost=65536,  # 64MB
    parallelism=4,  # Number of parallel threads
    hash_len=32,  # Length of the hash in bytes
    salt_len=16,  # Length of the salt in bytes
    encoding="utf-8",  # Encoding of the password
    type=Type.ID,  # Argon2id
)

# Authentication settings are accessed through the settings object


class ApiToken(BaseModel):
    """Model representing an API token entry with its hashed value"""

    key_id: UUID = Field(..., description="UUID identifier for the API key")
    token_hash: str = Field(..., description="Argon2id hash of the token")


def check_auth(
    credentials: Annotated[HTTPBasicCredentials, Depends(security)],
    settings: Annotated[TaskServerSettings, Depends(get_settings)],
):
    """
    Authenticate user with Argon2id-hashed token.

    Args:
        credentials: HTTP Basic authentication credentials
        settings: Application settings containing authentication config

    Returns:
        The authenticated key_id on success

    Raises:
        HTTPException: If authentication fails
    """
    # Get expected key ID and token hash from settings
    expected_key_id = settings.api_key_id
    token_hash = settings.api_token_hash

    # If either setting is missing, authentication fails
    if not expected_key_id or not token_hash:
        logger.error(
            "Authentication configuration is missing. Configure BUTTERCUP_TASK_SERVER_API_KEY_ID and "
            "BUTTERCUP_TASK_SERVER_API_TOKEN_HASH environment variables."
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication configuration error",
            headers={"WWW-Authenticate": "Basic"},
        )

    # Get credentials from request
    key_id = credentials.username
    token = credentials.password

    # Check if key ID matches
    if key_id != expected_key_id:
        logger.warning(f"Key ID from request ({key_id}) doesn't match expected key ID")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "Basic"},
        )

    # Verify token using Argon2id
    try:
        ph.verify(token_hash, token)
        return key_id
    except VerifyMismatchError:
        logger.warning(f"Invalid token provided for key ID {key_id}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
            headers={"WWW-Authenticate": "Basic"},
        )


@app.get("/status/", response_model=Status, tags=["status"])
def get_status_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
) -> Status:
    """
    CRS Status
    """

    # For internal processing, always consider system ready
    return Status(
        details={},
        ready=True,
        since=0,
        state=StatusState(tasks=get_status_tasks_state(settings.redis_url)),
        version=__version__,
    )


@app.delete("/status/", response_model=str, tags=["status"])
def delete_status_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
) -> str:
    """
    Reset status stats
    """
    logger.info("Resetting status")
    return ""


@app.post("/v1/sarif/", response_model=str, tags=["sarif"])
def post_v1_sarif_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    body: SARIFBroadcast,
    sarif_store: Annotated[SARIFStore, Depends(get_sarif_store)],
) -> str:
    """
    Submit Sarif Broadcast
    """
    logger.info("Accepting Sarif Broadcast: %s", body)
    return store_sarif_broadcast(body, sarif_store)


@app.post(
    "/v1/task/",
    response_model=None,
    responses={"202": {"model": str}},
    tags=["task"],
)
def post_v1_task_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    body: Task,
    tasks_queue: Annotated[ReliableQueue, Depends(get_task_queue)],
) -> Optional[str]:
    """
    Submit Task
    """
    logger.debug("Accepting Task: %s", body)
    return new_task(body, tasks_queue)


@app.delete("/v1/task/", response_model=str, tags=["task"])
def delete_v1_task_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    delete_task_queue: Annotated[ReliableQueue, Depends(get_delete_task_queue)],
) -> str:
    """
    Cancel All Tasks

    This endpoint allows canceling all existing tasks in the system. All tasks will be marked for deletion.

    Args:
        credentials: HTTP Basic authentication credentials required to access this endpoint
        delete_task_queue: Queue for processing task deletion requests

    Returns:
        str: Empty string on successful deletion request

    Raises:
        HTTPException: If authentication fails
    """
    logger.info("Deleting all tasks")
    return delete_all_tasks(delete_task_queue)


@app.delete("/v1/task/{task_id}/", response_model=str, tags=["task"])
def delete_v1_task_task_id_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    task_id: UUID,
    delete_task_queue: Annotated[ReliableQueue, Depends(get_delete_task_queue)],
) -> str:
    """
    Cancel a task by its ID.

    This endpoint allows canceling an existing task by its unique identifier. The task will be marked for deletion
    and removed from the system.

    Args:
        credentials: HTTP Basic authentication credentials required to access this endpoint
        task_id: The UUID of the task to cancel
        delete_task_queue: Queue for processing task deletion requests

    Returns:
        str: Empty string on successful deletion request

    Raises:
        HTTPException: If authentication fails
    """
    logger.info("Deleting task: %s", task_id)
    return delete_task(task_id, delete_task_queue)
