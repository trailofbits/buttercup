# generated by fastapi-codegen:
#   filename:  openapi.json
#   timestamp: 2025-01-23T10:58:54+00:00

from __future__ import annotations

import secrets
from typing import Annotated, Optional
from uuid import UUID

from fastapi import Depends, FastAPI, status, HTTPException
from fastapi.security import HTTPBasic, HTTPBasicCredentials

from buttercup.orchestrator.task_server.models.types import Status, Task, VulnBroadcast
from buttercup.orchestrator.task_server.backend import delete_task, new_task, get_system_status
from buttercup.common.logger import setup_package_logger
from buttercup.orchestrator.task_server.dependencies import get_delete_task_queue, get_task_queue, get_settings
from buttercup.common.queues import ReliableQueue

settings = get_settings()
logger = setup_package_logger(__name__, settings.log_level)

app = FastAPI(
    title="Buttercup CRS API",
    contact={},
    version="0.1",
    servers=[{"url": "/"}],
    log_config=None,
)

# The exposed endpoints must be authenticated using HTTP Basic.
# Credentials will be composed of an API key and token which will be used as the username
# and password in HTTP Basic Auth.
# API keys will be UUIds, tokens will be random alphanumeric strings of at least 32 chars.
# Tokens should be stored using Argon2ID.
security = HTTPBasic()


def check_auth(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):
    """
    Reference: https://fastapi.tiangolo.com/advanced/security/http-basic-auth/
    """
    current_username_bytes = credentials.username.encode("utf8")
    correct_username_bytes = b"api_key_id"  # FIXME: Change username as desired
    is_correct_username = secrets.compare_digest(current_username_bytes, correct_username_bytes)

    current_password_bytes = credentials.password.encode("utf8")
    correct_password_bytes = b"api_key_token"  # FIXME: Change password as desired and use hash
    is_correct_password = secrets.compare_digest(current_password_bytes, correct_password_bytes)

    if not (is_correct_username and is_correct_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials.username


@app.get("/status/", response_model=Status, tags=["status"])
def get_status_() -> Status:
    """
    Get CRS Status

    Returns the current system status including task states and system readiness.
    """
    return get_system_status()


@app.post("/v1/sarif/", response_model=str, tags=["sarif"])
def post_v1_sarif_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    body: VulnBroadcast,
) -> str:
    """
    Submit Sarif Broadcast
    """
    pass


@app.post(
    "/v1/task/",
    response_model=None,
    responses={"202": {"model": str}},
    tags=["task"],
)
def post_v1_task_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    body: Task,
    tasks_queue: Annotated[ReliableQueue, Depends(get_task_queue)],
) -> Optional[str]:
    """
    Submit Task
    """
    task_id = new_task(body, tasks_queue)
    return task_id


@app.delete("/v1/task/{task_id}/", response_model=str, tags=["task"])
def delete_v1_task_task_id_(
    credentials: Annotated[HTTPBasicCredentials, Depends(check_auth)],
    task_id: UUID,
    delete_task_queue: Annotated[ReliableQueue, Depends(get_delete_task_queue)],
) -> str:
    """
    Cancel a task by its ID.

    This endpoint allows canceling an existing task by its unique identifier. The task will be marked for deletion
    and removed from the system.

    Args:
        credentials: HTTP Basic authentication credentials required to access this endpoint
        task_id: The UUID of the task to cancel
        delete_task_queue: Queue for processing task deletion requests

    Returns:
        str: Empty string on successful deletion request

    Raises:
        HTTPException: If authentication fails
    """
    return delete_task(task_id, delete_task_queue)
