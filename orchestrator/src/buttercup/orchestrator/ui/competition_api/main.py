# generated by fastapi-codegen:
#   filename:  openapi.json
#   timestamp: 2025-07-08T08:15:58+00:00

from __future__ import annotations

from dataclasses import dataclass
import uuid
import json

from fastapi import FastAPI, Depends
from fastapi.responses import FileResponse

from buttercup.orchestrator.ui.competition_api.models.types import (
    BundleSubmission,
    BundleSubmissionResponse,
    BundleSubmissionResponseVerbose,
    Error,
    FreeformResponse,
    FreeformSubmission,
    Message,
    PatchSubmission,
    PatchSubmissionResponse,
    PingResponse,
    POVSubmission,
    POVSubmissionResponse,
    RequestListResponse,
    RequestSubmission,
    SarifAssessmentResponse,
    SarifAssessmentSubmission,
    SARIFSubmission,
    SARIFSubmissionResponse,
    SubmissionStatus,
)
from buttercup.orchestrator.ui.competition_api.services import ChallengeService, CRSClient
from buttercup.orchestrator.ui.config import Settings
import logging

logger = logging.getLogger(__name__)

app = FastAPI(
    title="Example Competition API",
    contact={},
    version="1.4.0",
    servers=[{"url": "/"}],
)

# Global settings instance
_settings: Settings | None = None


def get_settings() -> Settings:
    """Get application settings singleton."""
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings


def get_challenge_service() -> ChallengeService:
    """Get challenge service instance."""
    settings = get_settings()
    return ChallengeService(settings.storage_dir, f"http://{settings.host}:{settings.port}")


def get_crs_client() -> CRSClient:
    """Get CRS client instance."""
    settings = get_settings()
    return CRSClient(settings.crs_base_url, settings.crs_key_id, settings.crs_key_token)


@dataclass
class Challenge:
    name: str
    challenge_repo_url: str
    challenge_repo_head_ref: str
    fuzz_tooling_url: str
    fuzz_tooling_ref: str
    fuzz_tooling_project_name: str
    duration: int
    challenge_repo_base_ref: str | None = None


# NOTE: Make this dynamic and modifiable through the UI/API
challenges = [
    Challenge(
        name="upstream-libpng",
        challenge_repo_url="https://github.com/pnggroup/libpng",
        challenge_repo_head_ref="libpng16",
        fuzz_tooling_url="https://github.com/google/oss-fuzz",
        fuzz_tooling_ref="master",
        fuzz_tooling_project_name="libpng",
        duration=1800,
    ),
    Challenge(
        name="upstream-libpng-delta",
        challenge_repo_url="https://github.com/pnggroup/libpng",
        challenge_repo_head_ref="2b978915d82377df13fcbb1fb56660195ded868a",
        challenge_repo_base_ref="640204280f8109d7165f95d2b177f89baf20b253",
        fuzz_tooling_url="https://github.com/google/oss-fuzz",
        fuzz_tooling_ref="master",
        fuzz_tooling_project_name="libpng",
        duration=1800,
    ),
]


@app.get("/v1/ping/", response_model=PingResponse, tags=["ping"])
def get_v1_ping_() -> PingResponse:
    """
    Test authentication creds and network connectivity
    """
    return PingResponse(status="pong")


@app.get("/v1/crs-ping/", tags=["ping"])
def get_v1_crs_ping_(crs_client: CRSClient = Depends(get_crs_client)) -> dict:
    """
    Test connectivity to CRS
    """
    crs_ready = crs_client.ping()
    return {
        "crs_ready": crs_ready,
        "crs_base_url": crs_client.crs_base_url,
    }


@app.get(
    "/v1/request/list/",
    response_model=RequestListResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["request"],
)
def get_v1_request_list_() -> RequestListResponse | Error:
    """
    Get a list of available challenges to task
    """
    return RequestListResponse(challenges=[c.name for c in challenges])


@app.post(
    "/v1/request/{challenge_name}",
    response_model=Message,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["request"],
)
def post_v1_request_challenge_name(
    challenge_name: str,
    body: RequestSubmission,
    challenge_service: ChallengeService = Depends(get_challenge_service),
    crs_client: CRSClient = Depends(get_crs_client),
) -> Message | Error:
    """
    Send a task to the source of this request
    """
    if challenge_name not in [c.name for c in challenges]:
        return Error(message=f"Challenge {challenge_name} not found")

    # Find the challenge
    challenge = next(c for c in challenges if c.name == challenge_name)
    logger.info(f"Creating task for challenge {challenge_name}")

    # Get duration from request or use challenge default
    duration_secs = body.duration_secs or challenge.duration

    try:
        # Create task for the challenge
        task = challenge_service.create_task_for_challenge(
            challenge_name=challenge.name,
            challenge_repo_url=challenge.challenge_repo_url,
            challenge_repo_ref=challenge.challenge_repo_head_ref,
            challenge_repo_base_ref=challenge.challenge_repo_base_ref,
            fuzz_tooling_url=challenge.fuzz_tooling_url,
            fuzz_tooling_ref=challenge.fuzz_tooling_ref,
            fuzz_tooling_project_name=challenge.fuzz_tooling_project_name,
            duration_secs=duration_secs,
        )

        # Send task to CRS via POST /v1/task endpoint
        if crs_client.submit_task(task):
            logger.info(f"Task {task.tasks[0].task_id} submitted successfully to CRS")
            return Message(
                message=f"Task {task.tasks[0].task_id} created and submitted to CRS for challenge {challenge_name}"
            )
        else:
            logger.error(f"Failed to submit task {task.tasks[0].task_id} to CRS")
            return Error(message="Failed to submit task to CRS")

    except Exception as e:
        logger.error(f"Error creating task for challenge {challenge_name}: {e}")
        return Error(message=f"Failed to create task: {str(e)}")


@app.post(
    "/v1/task/{task_id}/broadcast-sarif-assessment/{broadcast_sarif_id}/",
    response_model=SarifAssessmentResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["broadcast-sarif-assessment"],
)
def post_v1_task_task_id_broadcast_sarif_assessment_broadcast_sarif_id_(
    task_id: str, broadcast_sarif_id: str, body: SarifAssessmentSubmission
) -> SarifAssessmentResponse | Error:
    """
    Submit a SARIF Assessment
    """
    logger.info(
        f"SARIF Assessment submission - Task: {task_id}, Broadcast SARIF ID: {broadcast_sarif_id}, Assessment: {body.assessment}, Description: {body.description[:100]}..."
    )
    return Error(message="Not implemented")


@app.post(
    "/v1/task/{task_id}/bundle/",
    response_model=BundleSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def post_v1_task_task_id_bundle_(task_id: str, body: BundleSubmission) -> BundleSubmissionResponse | Error:
    """
    Submit Bundle
    """
    bundle_id = str(uuid.uuid4())
    logger.info(f"Bundle submission - Task: {task_id}, Bundle ID: {bundle_id}")
    logger.info(f"Bundle details: {json.dumps(body.dict(), indent=2)}")
    return BundleSubmissionResponse(bundle_id=bundle_id, status=SubmissionStatus.SubmissionStatusAccepted)


@app.get(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    response_model=BundleSubmissionResponseVerbose,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def get_v1_task_task_id_bundle_bundle_id_(task_id: str, bundle_id: str) -> BundleSubmissionResponseVerbose | Error:
    """
    Get Bundle
    """
    logger.info(f"Bundle retrieval - Task: {task_id}, Bundle ID: {bundle_id}")
    return Error(message="Not implemented")


@app.delete(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    responses={
        "204": {},
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def delete_v1_task_task_id_bundle_bundle_id_(task_id: str, bundle_id: str) -> str | Error | None:
    """
    Delete Bundle
    """
    logger.info(f"Bundle deletion - Task: {task_id}, Bundle ID: {bundle_id}")
    return None


@app.patch(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    response_model=BundleSubmissionResponseVerbose,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def patch_v1_task_task_id_bundle_bundle_id_(
    task_id: str, bundle_id: str, body: BundleSubmission
) -> BundleSubmissionResponseVerbose | Error:
    """
    Update Bundle
    """
    logger.info(f"Bundle update - Task: {task_id}, Bundle ID: {bundle_id}")
    logger.info(f"Updated bundle details: {json.dumps(body.dict(), indent=2)}")
    return Error(message="Not implemented")


@app.post(
    "/v1/task/{task_id}/freeform/",
    response_model=FreeformResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["freeform"],
)
def post_v1_task_task_id_freeform_(task_id: str, body: FreeformSubmission) -> FreeformResponse | Error:
    """
    Submit Freeform
    """
    freeform_id = str(uuid.uuid4())
    logger.info(f"Freeform submission - Task: {task_id}, Freeform ID: {freeform_id}")
    logger.info(f"Freeform submission size: {len(body.submission)} bytes")
    return Error(message="Not implemented")


@app.post(
    "/v1/task/{task_id}/patch/",
    response_model=PatchSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["patch"],
)
def post_v1_task_task_id_patch_(task_id: str, body: PatchSubmission) -> PatchSubmissionResponse | Error:
    """
    Submit Patch
    """
    patch_id = str(uuid.uuid4())
    logger.info(f"Patch submission - Task: {task_id}, Patch ID: {patch_id}")
    logger.info(f"Patch size: {len(body.patch)} bytes")
    return PatchSubmissionResponse(
        patch_id=patch_id, status=SubmissionStatus.SubmissionStatusAccepted, functionality_tests_passing=None
    )


@app.get(
    "/v1/task/{task_id}/patch/{patch_id}/",
    response_model=PatchSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["patch"],
)
def get_v1_task_task_id_patch_patch_id_(task_id: str, patch_id: str) -> PatchSubmissionResponse | Error:
    """
    Patch Status
    """
    logger.info(f"Patch status check - Task: {task_id}, Patch ID: {patch_id}")
    return PatchSubmissionResponse(
        patch_id=patch_id, status=SubmissionStatus.SubmissionStatusPassed, functionality_tests_passing=True
    )


@app.post(
    "/v1/task/{task_id}/pov/",
    response_model=POVSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["pov"],
)
def post_v1_task_task_id_pov_(task_id: str, body: POVSubmission) -> POVSubmissionResponse | Error:
    """
    Submit Vulnerability
    """
    pov_id = str(uuid.uuid4())
    logger.info(f"POV submission - Task: {task_id}, POV ID: {pov_id}")
    logger.info(
        f"POV details: Architecture: {body.architecture}, Engine: {body.engine}, Fuzzer: {body.fuzzer_name}, Sanitizer: {body.sanitizer}"
    )
    logger.info(f"POV testcase size: {len(body.testcase)} bytes")
    return POVSubmissionResponse(pov_id=pov_id, status=SubmissionStatus.SubmissionStatusAccepted)


@app.get(
    "/v1/task/{task_id}/pov/{pov_id}/",
    response_model=POVSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["pov"],
)
def get_v1_task_task_id_pov_pov_id_(task_id: str, pov_id: str) -> POVSubmissionResponse | Error:
    """
    Vulnerability Status
    """
    logger.info(f"POV status check - Task: {task_id}, POV ID: {pov_id}")
    return POVSubmissionResponse(pov_id=pov_id, status=SubmissionStatus.SubmissionStatusPassed)


@app.post(
    "/v1/task/{task_id}/submitted-sarif/",
    response_model=SARIFSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["submitted-sarif"],
)
def post_v1_task_task_id_submitted_sarif_(task_id: str, body: SARIFSubmission) -> SARIFSubmissionResponse | Error:
    """
    Submit a CRS generated SARIF
    """
    submitted_sarif_id = str(uuid.uuid4())
    logger.info(f"SARIF submission - Task: {task_id}, Submitted SARIF ID: {submitted_sarif_id}")
    logger.info(f"SARIF content: {json.dumps(body.sarif, indent=2)}")
    return Error(message="Not implemented")


@app.get("/files/{tarball_name}.tar.gz", tags=["files"])
def get_tarball(
    tarball_name: str, challenge_service: ChallengeService = Depends(get_challenge_service)
) -> FileResponse:
    """
    Serve tarball files for CRS download
    """
    try:
        return challenge_service.serve_tarball(tarball_name)
    except Exception as e:
        logger.error(f"Error serving tarball {tarball_name}: {e}")
        raise
