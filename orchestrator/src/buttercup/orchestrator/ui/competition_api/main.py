# generated by fastapi-codegen:
#   filename:  openapi.json
#   timestamp: 2025-07-08T08:15:58+00:00
from __future__ import annotations
import uuid
import json
import base64
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from pathlib import Path

from fastapi import FastAPI, Depends, HTTPException
from fastapi.responses import FileResponse, HTMLResponse, Response
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

from buttercup.orchestrator.ui.competition_api.models.types import (
    BundleSubmission,
    BundleSubmissionResponse,
    BundleSubmissionResponseVerbose,
    Error,
    FreeformResponse,
    FreeformSubmission,
    Message,
    PatchSubmission,
    PatchSubmissionResponse,
    PingResponse,
    POVSubmission,
    POVSubmissionResponse,
    RequestListResponse,
    RequestSubmission,
    SarifAssessmentResponse,
    SarifAssessmentSubmission,
    SARIFSubmission,
    SARIFSubmissionResponse,
    SubmissionStatus,
)
from buttercup.orchestrator.ui.competition_api.services import ChallengeService, CRSClient
from buttercup.orchestrator.ui.config import Settings
from buttercup.orchestrator.ui.database import DatabaseManager, Task, Bundle, POV, Patch
from functools import cache
import logging

logger = logging.getLogger(__name__)

app = FastAPI(
    title="Example Competition API",
    contact={},
    version="1.4.0",
    servers=[{"url": "/"}],
)

# Global settings and database instances
_settings: Settings | None = None
_database_manager: DatabaseManager | None = None

# Compatibility - keeping dashboard_stats as backup/cache
dashboard_stats = {"activeTasks": 0, "totalPovs": 0, "totalPatches": 0, "totalBundles": 0}


# Dashboard models
class TaskInfo(BaseModel):
    task_id: str
    name: Optional[str] = None
    project_name: str
    status: str  # active, expired
    duration: int
    deadline: str
    challenge_repo_url: Optional[str] = None
    challenge_repo_head_ref: Optional[str] = None
    challenge_repo_base_ref: Optional[str] = None
    fuzz_tooling_url: Optional[str] = None
    fuzz_tooling_ref: Optional[str] = None
    povs: List[Dict[str, Any]] = []
    patches: List[Dict[str, Any]] = []
    bundles: List[Dict[str, Any]] = []
    created_at: str


class DashboardStats(BaseModel):
    activeTasks: int
    totalPovs: int
    totalPatches: int
    totalBundles: int


class Challenge(BaseModel):
    name: str | None = None

    challenge_repo_url: str
    challenge_repo_head_ref: str
    fuzz_tooling_url: str
    fuzz_tooling_ref: str
    fuzz_tooling_project_name: str
    duration: int
    challenge_repo_base_ref: str | None = None


# NOTE: Make this dynamic and modifiable through the UI/API
challenges = [
    Challenge(
        name="upstream-libpng",
        challenge_repo_url="https://github.com/pnggroup/libpng",
        challenge_repo_head_ref="libpng16",
        fuzz_tooling_url="https://github.com/google/oss-fuzz",
        fuzz_tooling_ref="master",
        fuzz_tooling_project_name="libpng",
        duration=1800,
    ),
    Challenge(
        name="upstream-libpng-delta",
        challenge_repo_url="https://github.com/pnggroup/libpng",
        challenge_repo_head_ref="2b978915d82377df13fcbb1fb56660195ded868a",
        challenge_repo_base_ref="640204280f8109d7165f95d2b177f89baf20b253",
        fuzz_tooling_url="https://github.com/google/oss-fuzz",
        fuzz_tooling_ref="master",
        fuzz_tooling_project_name="libpng",
        duration=1800,
    ),
]


def get_settings() -> Settings:
    """Get application settings singleton."""
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings


def get_database_manager() -> DatabaseManager:
    """Get database manager singleton."""
    global _database_manager
    if _database_manager is None:
        settings = get_settings()
        _database_manager = DatabaseManager(settings.database_url)
    return _database_manager


@cache
def get_run_data_dir() -> Path:
    """Get or create the current run data directory with timestamp."""
    settings = get_settings()
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    run_dir = settings.run_data_dir / f"run-data-{timestamp}"
    return run_dir


def save_artifact(
    task_id: str,
    artifact_type: str,
    artifact_id: str,
    content: str | dict,
    is_base64: bool = False,
) -> bool:
    """Save an artifact to the appropriate directory structure."""
    try:
        run_dir = get_run_data_dir()
        task_dir = run_dir / task_id / artifact_type
        task_dir.mkdir(parents=True, exist_ok=True)

        if artifact_type == "bundles":
            file_path = task_dir / f"{artifact_id}.json"
            with file_path.open("w", encoding="utf-8") as f:
                f.write(json.dumps(content, indent=2))
        elif artifact_type == "patches":
            assert isinstance(content, str)
            file_path = task_dir / f"{artifact_id}.patch"
            data = base64.b64decode(content).decode("utf-8") if is_base64 else content
            with file_path.open("w", encoding="utf-8") as f:
                f.write(data)
        elif artifact_type == "povs":
            assert isinstance(content, str)
            file_path = task_dir / f"{artifact_id}.bin"
            data_bin = base64.b64decode(content) if is_base64 else content.encode("utf-8")
            with file_path.open("wb") as f:
                f.write(data_bin)
        elif artifact_type == "sarifs":
            assert isinstance(content, dict)
            file_path = task_dir / f"{artifact_id}.sarif"
            with file_path.open("w", encoding="utf-8") as f:
                f.write(json.dumps(content, indent=2))
        else:
            logger.error(f"Unknown artifact type: {artifact_type}")
            return False

        logger.info(f"Saved {artifact_type} artifact: {file_path}")
        return True

    except Exception as e:
        logger.error(f"Failed to save {artifact_type} artifact {artifact_id} for task {task_id}: {e}")
        return False


def get_artifact(task_id: str, artifact_type: str, artifact_id: str) -> Any:
    """Get an artifact from the appropriate directory structure."""
    try:
        run_dir = get_run_data_dir()
        task_dir = run_dir / task_id / artifact_type
        if artifact_type == "bundles":
            file_path = task_dir / f"{artifact_id}.json"
            return json.load(file_path.open("r", encoding="utf-8"))
        elif artifact_type == "patches":
            file_path = task_dir / f"{artifact_id}.patch"
            return file_path.read_text()
        elif artifact_type == "povs":
            file_path = task_dir / f"{artifact_id}.bin"
            return file_path.read_bytes()
        elif artifact_type == "sarifs":
            file_path = task_dir / f"{artifact_id}.sarif"
            return json.load(file_path.open("r", encoding="utf-8"))
        else:
            logger.error(f"Unknown artifact type: {artifact_type}")
            return None
    except Exception:
        logger.exception(f"Failed to get {artifact_type} artifact {artifact_id} for task {task_id}")
        return None


def delete_artifact(task_id: str, artifact_type: str, artifact_id: str) -> bool:
    try:
        run_dir = get_run_data_dir()
        task_dir = run_dir / task_id / artifact_type
        if artifact_type == "bundles":
            file_path = task_dir / f"{artifact_id}.json"
        elif artifact_type == "patches":
            file_path = task_dir / f"{artifact_id}.patch"
        elif artifact_type == "povs":
            file_path = task_dir / f"{artifact_id}.bin"
        elif artifact_type == "sarifs":
            file_path = task_dir / f"{artifact_id}.sarif"
        else:
            logger.error(f"Unknown artifact type: {artifact_type}")
            return False

        # Rename the file to mark it as deleted (append .deleted to the filename)
        deleted_path = file_path.with_suffix(file_path.suffix + ".deleted")
        file_path.rename(deleted_path)
        return True
    except Exception:
        logger.exception(f"Failed to get {artifact_type} artifact {artifact_id} for task {task_id}")
        return False


def save_bundle(task_id: str, bundle_id: str, content: dict) -> bool:
    """Save a bundle to the appropriate directory structure."""
    return save_artifact(task_id, "bundles", bundle_id, content)


def save_patch(task_id: str, patch_id: str, content: str) -> bool:
    """Save a patch to the appropriate directory structure."""
    return save_artifact(task_id, "patches", patch_id, content, True)


def save_pov(task_id: str, pov_id: str, content: str) -> bool:
    """Save a POV to the appropriate directory structure."""
    return save_artifact(task_id, "povs", pov_id, content, True)


def save_sarif(task_id: str, sarif_id: str, content: dict) -> bool:
    """Save a SARIF to the appropriate directory structure."""
    return save_artifact(task_id, "sarifs", sarif_id, content, True)


def get_bundle(task_id: str, bundle_id: str) -> dict | None:
    artifact = get_artifact(task_id, "bundles", bundle_id)
    if artifact is None:
        return None

    assert isinstance(artifact, dict)
    return artifact


def get_challenge_service() -> ChallengeService:
    """Get challenge service instance."""
    settings = get_settings()
    return ChallengeService(settings.storage_dir, f"http://{settings.external_host}:{settings.port}")


def get_crs_client() -> CRSClient:
    """Get CRS client instance."""
    settings = get_settings()
    return CRSClient(settings.crs_base_url, settings.crs_key_id, settings.crs_key_token)


# Mount static files
static_dir = Path(__file__).parent.parent / "static"
if static_dir.exists():
    app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")


# Utility functions for task management
def calculate_task_status(deadline: datetime) -> str:
    """Calculate task status based on deadline."""
    try:
        now = datetime.now(deadline.tzinfo)
        if now > deadline:
            return "expired"
        return "active"
    except Exception:
        return "active"  # Default to active if parsing fails


def update_dashboard_stats(database_manager: DatabaseManager) -> None:
    """Update dashboard statistics from current tasks."""
    global dashboard_stats

    active_count = 0
    total_povs = 0
    total_patches = 0
    total_bundles = 0
    with database_manager.get_all_tasks() as tasks:
        for task in tasks:
            if calculate_task_status(task.deadline) == "active":
                active_count += 1

            total_povs += len(task.povs)
            total_patches += len(task.patches)
            total_bundles += len(task.bundles)

    dashboard_stats.update(
        {
            "activeTasks": active_count,
            "totalPovs": total_povs,
            "totalPatches": total_patches,
            "totalBundles": total_bundles,
        }
    )


def pov_to_pov_info(pov: POV) -> dict[str, Any]:
    return {
        "pov_id": pov.pov_id,
        "timestamp": pov.created_at,
        "architecture": pov.architecture,
        "engine": pov.engine,
        "fuzzer_name": pov.fuzzer_name,
        "sanitizer": pov.sanitizer,
        "testcase": base64.b64encode(pov.testcase),
    }


def patch_to_patch_info(patch: Patch) -> dict[str, Any]:
    return {
        "patch_id": patch.patch_id,
        "timestamp": patch.created_at,
        "patch": base64.b64encode(patch.patch.encode("utf-8", errors="ignore")),
    }


def bundle_to_bundle_info(bundle: Bundle) -> dict[str, Any]:
    return {
        "bundle_id": bundle.bundle_id,
        "timestamp": bundle.created_at,
        "description": bundle.description,
        "broadcast_sarif_id": bundle.broadcast_sarif_id,
        "freeform_id": bundle.freeform_id,
        "patch_id": bundle.patch_id,
        "pov_id": bundle.pov_id,
        "submitted_sarif_id": bundle.submitted_sarif_id,
    }


def task_to_task_info(task: Task) -> TaskInfo:
    """Convert a task to a TaskInfo object."""
    povs = []
    for pov in task.povs:
        povs.append(pov_to_pov_info(pov))

    patches = []
    for patch in task.patches:
        patches.append(patch_to_patch_info(patch))

    bundles = []
    for bundle in task.bundles:
        bundles.append(bundle_to_bundle_info(bundle))

    task_data = {
        "task_id": task.task_id,
        "name": task.name,
        "project_name": task.project_name,
        "status": calculate_task_status(task.deadline),
        "duration": task.duration,
        "deadline": datetime.isoformat(task.deadline),
        "challenge_repo_url": task.challenge_repo_url,
        "challenge_repo_head_ref": task.challenge_repo_head_ref,
        "challenge_repo_base_ref": task.challenge_repo_base_ref,
        "fuzz_tooling_url": task.fuzz_tooling_url,
        "fuzz_tooling_ref": task.fuzz_tooling_ref,
        "created_at": datetime.isoformat(task.created_at),
        "povs": povs,
        "patches": patches,
        "bundles": bundles,
    }

    return TaskInfo(**task_data)


def _create_task(
    challenge: Challenge, challenge_service: ChallengeService, crs_client: CRSClient, database_manager: DatabaseManager
) -> Message | Error:
    try:
        # Create task for the challenge
        task = challenge_service.create_task_for_challenge(
            challenge_repo_url=challenge.challenge_repo_url,
            challenge_repo_ref=challenge.challenge_repo_head_ref,
            challenge_repo_base_ref=challenge.challenge_repo_base_ref,
            fuzz_tooling_url=challenge.fuzz_tooling_url,
            fuzz_tooling_ref=challenge.fuzz_tooling_ref,
            fuzz_tooling_project_name=challenge.fuzz_tooling_project_name,
            duration_secs=challenge.duration,
        )

        # Store task data in database
        task_id = task.tasks[0].task_id
        name = challenge.name or task_id
        now = datetime.now()
        deadline = now + timedelta(seconds=challenge.duration)

        database_manager.create_task(
            task_id=task_id,
            name=name,
            project_name=challenge.fuzz_tooling_project_name,
            status="active",
            duration=challenge.duration,
            deadline=deadline,
            challenge_repo_url=challenge.challenge_repo_url,
            challenge_repo_head_ref=challenge.challenge_repo_head_ref,
            challenge_repo_base_ref=challenge.challenge_repo_base_ref,
            fuzz_tooling_url=challenge.fuzz_tooling_url,
            fuzz_tooling_ref=challenge.fuzz_tooling_ref,
        )

        # Send task to CRS via POST /v1/task endpoint
        if crs_client.submit_task(task):
            logger.info(f"Task {task_id} submitted successfully to CRS")
            return Message(message=f"Task {task_id} created and submitted to CRS for challenge {challenge.name}")
        else:
            logger.error(f"Failed to submit task {task_id} to CRS")
            return Error(message="Failed to submit task to CRS")

    except Exception as e:
        logger.error(f"Error creating task for challenge {challenge.name}: {e}")
        return Error(message=f"Failed to create task: {str(e)}")


def _create_sarif_broadcast(
    body: dict[str, Any], challenge_service: ChallengeService, crs_client: CRSClient
) -> Message | Error:
    """
    Create a SARIF Broadcast
    """
    if "task_id" not in body:
        return Error(message="Task ID is required")
    task_id = body["task_id"]

    if "sarif" not in body:
        return Error(message="SARIF body is required")

    sarif = body["sarif"]
    broadcast = challenge_service.create_sarif_broadcast(task_id, sarif)
    if crs_client.submit_sarif_broadcast(broadcast):
        return Message(message=f"SARIF Broadcast for Task {task_id} created and submitted to CRS")
    else:
        return Error(message=f"Failed to submit SARIF Broadcast for Task {task_id} to CRS")


@app.get("/v1/ping/", response_model=PingResponse, tags=["ping"])
def get_v1_ping_() -> PingResponse:
    """
    Test authentication creds and network connectivity
    """
    return PingResponse(status="pong")


@app.get("/v1/crs-ping/", tags=["ping"])
def get_v1_crs_ping_(crs_client: CRSClient = Depends(get_crs_client)) -> dict:
    """
    Test connectivity to CRS
    """
    crs_ready = crs_client.ping()
    return {
        "crs_ready": crs_ready,
        "crs_base_url": crs_client.crs_base_url,
    }


# Dashboard endpoints
@app.get("/", response_class=HTMLResponse, tags=["dashboard"])
def get_dashboard() -> HTMLResponse:
    """
    Serve the main dashboard HTML page
    """
    static_dir = Path(__file__).parent.parent / "static"
    html_file = static_dir / "index.html"

    if html_file.exists():
        return HTMLResponse(content=html_file.read_text(), status_code=200)
    else:
        return HTMLResponse(content="<h1>Dashboard not found</h1>", status_code=404)


@app.get("/v1/dashboard/stats", response_model=DashboardStats, tags=["dashboard"])
def get_dashboard_stats(database_manager: DatabaseManager = Depends(get_database_manager)) -> DashboardStats:
    """
    Get dashboard statistics
    """
    update_dashboard_stats(database_manager)
    return DashboardStats(**dashboard_stats)


@app.get("/v1/dashboard/tasks", response_model=List[TaskInfo], tags=["dashboard"])
def get_dashboard_tasks(database_manager: DatabaseManager = Depends(get_database_manager)) -> List[TaskInfo]:
    """
    Get list of all tasks for dashboard
    """
    update_dashboard_stats(database_manager)
    with database_manager.get_all_tasks() as tasks:
        tasks_list = []
        for task in tasks:
            tasks_list.append(task_to_task_info(task))

    # Sort by created_at descending (newest first)
    tasks_list.sort(key=lambda x: x.created_at, reverse=True)
    return tasks_list


@app.get("/v1/dashboard/tasks/{task_id}", response_model=TaskInfo, tags=["dashboard"])
def get_dashboard_task(task_id: str, database_manager: DatabaseManager = Depends(get_database_manager)) -> TaskInfo:
    """
    Get detailed information about a specific task
    """
    with database_manager.get_task(task_id) as task:
        if not task:
            raise HTTPException(status_code=404, detail="Task not found")

        return task_to_task_info(task)


@app.get(
    "/v1/request/list/",
    response_model=RequestListResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["request"],
)
def get_v1_request_list_() -> RequestListResponse | Error:
    """
    Get a list of available challenges to task
    """
    return RequestListResponse(challenges=[c.name for c in challenges if c.name is not None])


@app.post(
    "/v1/request/{challenge_name}",
    response_model=Message,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["request"],
)
def post_v1_request_challenge_name(
    challenge_name: str,
    body: RequestSubmission,
    challenge_service: ChallengeService = Depends(get_challenge_service),
    crs_client: CRSClient = Depends(get_crs_client),
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> Message | Error:
    """
    Send a task to the source of this request
    """
    if challenge_name not in [c.name for c in challenges]:
        return Error(message=f"Challenge {challenge_name} not found")

    # Find the challenge
    challenge = next(c for c in challenges if c.name == challenge_name)
    logger.info(f"Creating task for challenge {challenge_name}")

    # Get duration from request or use challenge default
    if body.duration_secs:
        challenge.duration = body.duration_secs

    return _create_task(challenge, challenge_service, crs_client, database_manager)


@app.post(
    "/v1/task/{task_id}/broadcast-sarif-assessment/{broadcast_sarif_id}/",
    response_model=SarifAssessmentResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["broadcast-sarif-assessment"],
)
def post_v1_task_task_id_broadcast_sarif_assessment_broadcast_sarif_id_(
    task_id: str, broadcast_sarif_id: str, body: SarifAssessmentSubmission
) -> SarifAssessmentResponse | Error:
    """
    Submit a SARIF Assessment
    """
    logger.info(
        f"SARIF Assessment submission - Task: {task_id}, Broadcast SARIF ID: {broadcast_sarif_id}, Assessment: {body.assessment}, Description: {body.description[:100]}..."
    )
    return SarifAssessmentResponse(status=SubmissionStatus.SubmissionStatusAccepted)


@app.post(
    "/v1/task/{task_id}/bundle/",
    response_model=BundleSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def post_v1_task_task_id_bundle_(
    task_id: str, body: BundleSubmission, database_manager: DatabaseManager = Depends(get_database_manager)
) -> BundleSubmissionResponse | Error:
    """
    Submit Bundle
    """
    logger.info(f"Bundle submission - Task: {task_id}")
    logger.debug(f"Bundle details: {json.dumps(body.model_dump(), indent=2)}")

    bundle = database_manager.create_bundle(
        task_id=task_id,
        broadcast_sarif_id=body.broadcast_sarif_id,
        description=body.description,
        freeform_id=body.freeform_id,
        patch_id=body.patch_id,
        pov_id=body.pov_id,
        submitted_sarif_id=body.submitted_sarif_id,
    )

    save_bundle(task_id, bundle.bundle_id, body.model_dump())

    return BundleSubmissionResponse(bundle_id=bundle.bundle_id, status=SubmissionStatus.SubmissionStatusAccepted)


@app.get(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    response_model=BundleSubmissionResponseVerbose,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def get_v1_task_task_id_bundle_bundle_id_(
    task_id: str, bundle_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> BundleSubmissionResponseVerbose | Error:
    """
    Get Bundle
    """
    logger.info(f"Bundle retrieval - Task: {task_id}, Bundle ID: {bundle_id}")
    with database_manager.get_bundle(bundle_id, task_id) as bundle:
        if bundle is None:
            return Error(message=f"Bundle {bundle_id} not found")

        return BundleSubmissionResponseVerbose(
            broadcast_sarif_id=bundle.broadcast_sarif_id,
            bundle_id=bundle_id,
            description=bundle.description,
            freeform_id=bundle.freeform_id,
            patch_id=bundle.patch_id,
            pov_id=bundle.pov_id,
            submitted_sarif_id=bundle.submitted_sarif_id,
            status=SubmissionStatus.SubmissionStatusAccepted,
        )


@app.delete(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    responses={
        "204": {},
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def delete_v1_task_task_id_bundle_bundle_id_(
    task_id: str, bundle_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> str | Error | None:
    """
    Delete Bundle
    """
    logger.info(f"Bundle deletion - Task: {task_id}, Bundle ID: {bundle_id}")
    with database_manager.get_bundle(bundle_id, task_id) as bundle:
        if bundle is None:
            return Error(message=f"Bundle {bundle_id} not found")

        database_manager.delete_bundle(bundle)
        delete_artifact(task_id, "bundles", bundle_id)

    return None


@app.patch(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    response_model=BundleSubmissionResponseVerbose,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def patch_v1_task_task_id_bundle_bundle_id_(
    task_id: str,
    bundle_id: str,
    body: BundleSubmission,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> BundleSubmissionResponseVerbose | Error:
    """
    Update Bundle
    """
    logger.info(f"Bundle update - Task: {task_id}, Bundle ID: {bundle_id}")
    logger.info(f"Updated bundle details: {json.dumps(body.model_dump(), indent=2)}")

    with database_manager.get_bundle(bundle_id, task_id) as bundle:
        if bundle is None:
            return Error(message=f"Bundle {bundle_id} not found")

        bundle.broadcast_sarif_id = body.broadcast_sarif_id or bundle.broadcast_sarif_id
        bundle.description = body.description or bundle.description
        bundle.freeform_id = body.freeform_id or bundle.freeform_id
        bundle.patch_id = body.patch_id or bundle.patch_id
        bundle.pov_id = body.pov_id or bundle.pov_id
        bundle.submitted_sarif_id = body.submitted_sarif_id or bundle.submitted_sarif_id

        # Save bundle to disk (for backward compatibility)
        save_bundle(task_id, bundle_id, body.model_dump())

        return BundleSubmissionResponseVerbose(
            broadcast_sarif_id=bundle.broadcast_sarif_id,
            bundle_id=bundle_id,
            description=bundle.description,
            freeform_id=bundle.freeform_id,
            patch_id=bundle.patch_id,
            pov_id=bundle.pov_id,
            submitted_sarif_id=bundle.submitted_sarif_id,
            status=SubmissionStatus.SubmissionStatusAccepted,
        )


@app.post(
    "/v1/task/{task_id}/freeform/",
    response_model=FreeformResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["freeform"],
)
def post_v1_task_task_id_freeform_(task_id: str, body: FreeformSubmission) -> FreeformResponse | Error:
    """
    Submit Freeform
    """
    freeform_id = str(uuid.uuid4())
    logger.info(f"Freeform submission - Task: {task_id}, Freeform ID: {freeform_id}")
    logger.info(f"Freeform submission size: {len(body.submission)} bytes")
    return Error(message="Not implemented")


@app.post(
    "/v1/task/{task_id}/patch/",
    response_model=PatchSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["patch"],
)
def post_v1_task_task_id_patch_(
    task_id: str, body: PatchSubmission, database_manager: DatabaseManager = Depends(get_database_manager)
) -> PatchSubmissionResponse | Error:
    """
    Submit Patch
    """
    logger.info(f"Patch submission - Task: {task_id}")
    logger.debug(f"Patch details: {json.dumps(body.model_dump(), indent=2)}")

    patch = database_manager.create_patch(
        task_id=task_id,
        patch=base64.b64decode(body.patch).decode("utf-8", errors="ignore"),
    )
    save_patch(task_id, patch.patch_id, body.patch)

    return PatchSubmissionResponse(
        patch_id=patch.patch_id, status=SubmissionStatus.SubmissionStatusAccepted, functionality_tests_passing=None
    )


@app.get(
    "/v1/task/{task_id}/patch/{patch_id}/",
    response_model=PatchSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["patch"],
)
def get_v1_task_task_id_patch_patch_id_(
    task_id: str, patch_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> PatchSubmissionResponse | Error:
    """
    Patch Status
    """
    logger.info(f"Patch status check - Task: {task_id}, Patch ID: {patch_id}")
    with database_manager.get_patch(patch_id, task_id) as patch:
        if patch is None:
            return Error(message=f"Patch {patch_id} not found")

    return PatchSubmissionResponse(
        patch_id=patch_id, status=SubmissionStatus.SubmissionStatusPassed, functionality_tests_passing=True
    )


@app.post(
    "/v1/task/{task_id}/pov/",
    response_model=POVSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["pov"],
)
def post_v1_task_task_id_pov_(
    task_id: str, body: POVSubmission, database_manager: DatabaseManager = Depends(get_database_manager)
) -> POVSubmissionResponse | Error:
    """
    Submit Vulnerability
    """
    logger.info(f"POV submission - Task: {task_id}")
    logger.debug(
        f"POV details: architecture={body.architecture.value}, engine={body.engine.value}, fuzzer_name={body.fuzzer_name}, sanitizer={body.sanitizer}"
    )

    with database_manager.get_task(task_id) as task:
        if task is None:
            return Error(message=f"Task {task_id} not found")

    pov = database_manager.create_pov(
        task_id=task_id,
        architecture=body.architecture.value,
        engine=body.engine.value,
        fuzzer_name=body.fuzzer_name,
        sanitizer=body.sanitizer,
        testcase=base64.b64decode(body.testcase),
    )
    save_pov(task_id, pov.pov_id, body.testcase)

    return POVSubmissionResponse(pov_id=pov.pov_id, status=SubmissionStatus.SubmissionStatusAccepted)


@app.get(
    "/v1/task/{task_id}/pov/{pov_id}/",
    response_model=POVSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["pov"],
)
def get_v1_task_task_id_pov_pov_id_(
    task_id: str, pov_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> POVSubmissionResponse | Error:
    """
    Vulnerability Status
    """
    logger.info(f"POV status check - Task: {task_id}, POV ID: {pov_id}")
    with database_manager.get_pov(pov_id, task_id) as pov:
        if pov is None:
            return Error(message=f"POV {pov_id} not found")

    return POVSubmissionResponse(pov_id=pov_id, status=SubmissionStatus.SubmissionStatusPassed)


@app.post(
    "/v1/task/{task_id}/submitted-sarif/",
    response_model=SARIFSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["submitted-sarif"],
)
def post_v1_task_task_id_submitted_sarif_(task_id: str, body: SARIFSubmission) -> SARIFSubmissionResponse | Error:
    """
    Submit a CRS generated SARIF
    """
    submitted_sarif_id = str(uuid.uuid4())
    logger.info(f"SARIF submission - Task: {task_id}, Submitted SARIF ID: {submitted_sarif_id}")
    logger.info(f"SARIF content: {json.dumps(body.sarif, indent=2)}")

    save_sarif(task_id, submitted_sarif_id, body.sarif)

    return SARIFSubmissionResponse(
        submitted_sarif_id=submitted_sarif_id, status=SubmissionStatus.SubmissionStatusPassed
    )


@app.get("/files/{tarball_name}.tar.gz", tags=["files"])
def get_tarball(
    tarball_name: str, challenge_service: ChallengeService = Depends(get_challenge_service)
) -> FileResponse:
    """
    Serve tarball files for CRS download
    """
    try:
        return challenge_service.serve_tarball(tarball_name)
    except Exception as e:
        logger.error(f"Error serving tarball {tarball_name}: {e}")
        raise


@app.post("/webhook/trigger_task")
def trigger_task(
    body: Challenge,
    challenge_service: ChallengeService = Depends(get_challenge_service),
    crs_client: CRSClient = Depends(get_crs_client),
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> Message | Error:
    """
    Trigger a task
    """
    logger.info(f"Triggering task: {body.model_dump()}")
    return _create_task(body, challenge_service, crs_client, database_manager)


@app.post("/webhook/sarif")
def trigger_sarif(
    body: dict[str, Any],
    challenge_service: ChallengeService = Depends(get_challenge_service),
    crs_client: CRSClient = Depends(get_crs_client),
) -> Message | Error:
    """
    Trigger a SARIF Broadcast
    """
    logger.info(f"Triggering SARIF Broadcast: {json.dumps(body, indent=2)}")
    return _create_sarif_broadcast(body, challenge_service, crs_client)


# Download endpoints for PoVs, Patches, and Bundles
@app.get("/v1/dashboard/tasks/{task_id}/povs/{pov_id}/download", tags=["dashboard"])
def download_pov(
    task_id: str, pov_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> Response:
    """Download a PoV testcase"""
    with database_manager.get_pov(pov_id, task_id) as pov:
        if pov is None:
            raise HTTPException(status_code=404, detail="POV not found")

        return Response(
            content=pov.testcase,
            media_type="application/octet-stream",
            headers={"Content-Disposition": f"attachment; filename=pov_{pov_id}.bin"},
        )


@app.get("/v1/dashboard/tasks/{task_id}/patches/{patch_id}/download", tags=["dashboard"])
def download_patch(
    task_id: str, patch_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> Response:
    """Download a patch"""
    with database_manager.get_patch(patch_id, task_id) as patch:
        if patch is None:
            raise HTTPException(status_code=404, detail="Patch not found")

        return Response(
            content=patch.patch,
            media_type="text/plain",
            headers={"Content-Disposition": f"attachment; filename=patch_{patch_id}.patch"},
        )


@app.get("/v1/dashboard/tasks/{task_id}/bundles/{bundle_id}/download", tags=["dashboard"])
def download_bundle(
    task_id: str, bundle_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> Response:
    """Download a bundle as JSON"""
    with database_manager.get_bundle(bundle_id, task_id) as bundle:
        if bundle is None:
            raise HTTPException(status_code=404, detail="Bundle not found")

        # Convert bundle to dict format for JSON serialization
        bundle_dict = bundle_to_bundle_info(bundle)
        bundle_json = json.dumps(bundle_dict, indent=2)

    return Response(
        content=bundle_json,
        media_type="application/json",
        headers={"Content-Disposition": f"attachment; filename=bundle_{bundle_id}.json"},
    )


# Detail view endpoints
@app.get("/v1/dashboard/povs/{pov_id}", tags=["dashboard"])
def get_pov_detail(pov_id: str, database_manager: DatabaseManager = Depends(get_database_manager)) -> Dict[str, Any]:
    """Get detailed information about a specific PoV"""
    with database_manager.get_pov(pov_id) as pov:
        if pov is None:
            raise HTTPException(status_code=404, detail="POV not found")

        pov_dict = pov_to_pov_info(pov)
        return {
            "task_id": pov.task_id,
            "task_name": pov.task.name or pov.task.project_name,
            "pov": pov_dict,
        }


@app.get("/v1/dashboard/patches/{patch_id}", tags=["dashboard"])
def get_patch_detail(
    patch_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> Dict[str, Any]:
    """Get detailed information about a specific patch"""
    with database_manager.get_patch(patch_id) as patch:
        if patch is None:
            raise HTTPException(status_code=404, detail="Patch not found")

        patch_dict = patch_to_patch_info(patch)
        return {
            "task_id": patch.task_id,
            "task_name": patch.task.name or patch.task.project_name,
            "patch": patch_dict,
        }


@app.get("/v1/dashboard/bundles/{bundle_id}", tags=["dashboard"])
def get_bundle_detail(
    bundle_id: str, database_manager: DatabaseManager = Depends(get_database_manager)
) -> Dict[str, Any]:
    """Get detailed information about a specific bundle"""
    with database_manager.get_bundle(bundle_id) as bundle:
        if bundle is None:
            raise HTTPException(status_code=404, detail="Bundle not found")

        bundle_dict = bundle_to_bundle_info(bundle)
        return {
            "task_id": bundle.task_id,
            "task_name": bundle.task.name or bundle.task.project_name,
            "bundle": bundle_dict,
        }


# List all PoVs and Patches across tasks
@app.get("/v1/dashboard/povs", tags=["dashboard"])
def get_all_povs(database_manager: DatabaseManager = Depends(get_database_manager)) -> List[Dict[str, Any]]:
    """Get all PoVs across all tasks"""
    all_povs: list[dict[str, Any]] = []

    with database_manager.get_all_povs() as povs:
        for pov in povs:
            pov_dict = pov_to_pov_info(pov)
            all_povs.append(
                {
                    "task_id": pov.task_id,
                    "task_name": pov.task.name or pov.task.project_name,
                    "pov": pov_dict,
                }
            )

    all_povs.sort(key=lambda x: x["pov"].get("timestamp", ""), reverse=True)
    return all_povs


@app.get("/v1/dashboard/patches", tags=["dashboard"])
def get_all_patches(database_manager: DatabaseManager = Depends(get_database_manager)) -> List[Dict[str, Any]]:
    """Get all patches across all tasks"""
    all_patches: list[dict[str, Any]] = []

    with database_manager.get_all_patches() as patches:
        for patch in patches:
            patch_dict = patch_to_patch_info(patch)
            all_patches.append(
                {
                    "task_id": patch.task_id,
                    "task_name": patch.task.name or patch.task.project_name,
                    "patch": patch_dict,
                }
            )

    # Sort by timestamp descending
    all_patches.sort(key=lambda x: x["patch"].get("timestamp", ""), reverse=True)
    return all_patches
