# generated by fastapi-codegen:
#   filename:  openapi.json
#   timestamp: 2025-07-08T08:15:58+00:00
from __future__ import annotations

import base64
import json
import logging
import uuid
from datetime import datetime, timedelta
from functools import cache
from pathlib import Path
from typing import Any, List, Optional

from fastapi import Depends, FastAPI, HTTPException
from fastapi.responses import FileResponse, HTMLResponse, Response
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

from buttercup.common.telemetry import crs_instance_id
from buttercup.orchestrator.ui.competition_api.models.types import (
    BundleSubmission,
    BundleSubmissionResponse,
    BundleSubmissionResponseVerbose,
    Error,
    FreeformResponse,
    FreeformSubmission,
    Message,
    PatchSubmission,
    PatchSubmissionResponse,
    PingResponse,
    POVSubmission,
    POVSubmissionResponse,
    RequestListResponse,
    RequestSubmission,
    SarifAssessmentResponse,
    SarifAssessmentSubmission,
    SARIFSubmission,
    SARIFSubmissionResponse,
    SubmissionStatus,
)
from buttercup.orchestrator.ui.competition_api.services import ChallengeService, CRSClient
from buttercup.orchestrator.ui.config import Settings
from buttercup.orchestrator.ui.database import POV, Bundle, DatabaseManager, Patch, Task

logger = logging.getLogger(__name__)

app = FastAPI(
    title="Example Competition API",
    contact={},
    version="1.4.0",
    servers=[{"url": "/"}],
)

# Global settings and database instances
_settings: Settings | None = None
_database_manager: DatabaseManager | None = None

# Compatibility - keeping dashboard_stats as backup/cache
dashboard_stats = {"activeTasks": 0, "totalPovs": 0, "totalPatches": 0, "totalBundles": 0, "failedTasks": 0}


# Dashboard models
class TaskInfo(BaseModel):
    task_id: str
    name: str | None = None
    project_name: str
    status: str  # active, expired
    duration: int
    deadline: str
    challenge_repo_url: str | None = None
    challenge_repo_head_ref: str | None = None
    challenge_repo_base_ref: str | None = None
    fuzz_tooling_url: str | None = None
    fuzz_tooling_ref: str | None = None
    povs: list[dict[str, Any]] = []
    patches: list[dict[str, Any]] = []
    bundles: list[dict[str, Any]] = []
    created_at: str

    # CRS submission status and error information
    crs_submission_status: Optional[str] = None  # 'pending', 'success', 'failed'
    crs_submission_error: Optional[str] = None
    crs_error_details: Optional[str] = None  # JSON string
    crs_submission_timestamp: Optional[str] = None


class DashboardStats(BaseModel):
    activeTasks: int
    totalPovs: int
    totalPatches: int
    totalBundles: int
    failedTasks: int


class Challenge(BaseModel):
    name: str | None = None

    challenge_repo_url: str
    challenge_repo_head_ref: str
    fuzz_tooling_url: str
    fuzz_tooling_ref: str
    fuzz_tooling_project_name: str
    duration: int
    challenge_repo_base_ref: str | None = None


# NOTE: Make this dynamic and modifiable through the UI/API
challenges = [
    Challenge(
        name="upstream-libpng",
        challenge_repo_url="https://github.com/pnggroup/libpng",
        challenge_repo_head_ref="libpng16",
        fuzz_tooling_url="https://github.com/google/oss-fuzz",
        fuzz_tooling_ref="master",
        fuzz_tooling_project_name="libpng",
        duration=1800,
    ),
    Challenge(
        name="upstream-libpng-delta",
        challenge_repo_url="https://github.com/pnggroup/libpng",
        challenge_repo_head_ref="2b978915d82377df13fcbb1fb56660195ded868a",
        challenge_repo_base_ref="640204280f8109d7165f95d2b177f89baf20b253",
        fuzz_tooling_url="https://github.com/google/oss-fuzz",
        fuzz_tooling_ref="master",
        fuzz_tooling_project_name="libpng",
        duration=1800,
    ),
]


def get_settings() -> Settings:
    """Get application settings singleton."""
    global _settings
    if _settings is None:
        _settings = Settings()
    return _settings


def get_database_manager() -> DatabaseManager:
    """Get database manager singleton."""
    global _database_manager
    if _database_manager is None:
        settings = get_settings()
        _database_manager = DatabaseManager(settings.database_url)
    return _database_manager


@cache
def get_run_data_dir() -> Path:
    """Get or create the current run data directory with timestamp."""
    settings = get_settings()
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    run_dir = settings.run_data_dir / f"run-data-{timestamp}"
    return run_dir


def save_artifact(
    task_id: str,
    artifact_type: str,
    artifact_id: str,
    content: str | dict,
    is_base64: bool = False,
) -> bool:
    """Save an artifact to the appropriate directory structure."""
    try:
        run_dir = get_run_data_dir()
        task_dir = run_dir / task_id / artifact_type
        task_dir.mkdir(parents=True, exist_ok=True)

        if artifact_type == "bundles":
            file_path = task_dir / f"{artifact_id}.json"
            with file_path.open("w", encoding="utf-8") as f:
                f.write(json.dumps(content, indent=2))
        elif artifact_type == "patches":
            assert isinstance(content, str)
            file_path = task_dir / f"{artifact_id}.patch"
            data = base64.b64decode(content).decode("utf-8") if is_base64 else content
            with file_path.open("w", encoding="utf-8") as f:
                f.write(data)
        elif artifact_type == "povs":
            assert isinstance(content, str)
            file_path = task_dir / f"{artifact_id}.bin"
            data_bin = base64.b64decode(content) if is_base64 else content.encode("utf-8")
            with file_path.open("wb") as f:
                f.write(data_bin)
        elif artifact_type == "sarifs":
            assert isinstance(content, dict)
            file_path = task_dir / f"{artifact_id}.sarif"
            with file_path.open("w", encoding="utf-8") as f:
                f.write(json.dumps(content, indent=2))
        else:
            logger.error(f"Unknown artifact type: {artifact_type}")
            return False

        logger.info(f"Saved {artifact_type} artifact: {file_path}")
        return True

    except Exception as e:
        logger.error(f"Failed to save {artifact_type} artifact {artifact_id} for task {task_id}: {e}")
        return False


def get_artifact(task_id: str, artifact_type: str, artifact_id: str) -> Any:
    """Get an artifact from the appropriate directory structure."""
    try:
        run_dir = get_run_data_dir()
        task_dir = run_dir / task_id / artifact_type
        if artifact_type == "bundles":
            file_path = task_dir / f"{artifact_id}.json"
            return json.load(file_path.open("r", encoding="utf-8"))
        if artifact_type == "patches":
            file_path = task_dir / f"{artifact_id}.patch"
            return file_path.read_text()
        if artifact_type == "povs":
            file_path = task_dir / f"{artifact_id}.bin"
            return file_path.read_bytes()
        if artifact_type == "sarifs":
            file_path = task_dir / f"{artifact_id}.sarif"
            return json.load(file_path.open("r", encoding="utf-8"))
        logger.error(f"Unknown artifact type: {artifact_type}")
        return None
    except Exception:
        logger.exception(f"Failed to get {artifact_type} artifact {artifact_id} for task {task_id}")
        return None


def delete_artifact(task_id: str, artifact_type: str, artifact_id: str) -> bool:
    try:
        run_dir = get_run_data_dir()
        task_dir = run_dir / task_id / artifact_type
        if artifact_type == "bundles":
            file_path = task_dir / f"{artifact_id}.json"
        elif artifact_type == "patches":
            file_path = task_dir / f"{artifact_id}.patch"
        elif artifact_type == "povs":
            file_path = task_dir / f"{artifact_id}.bin"
        elif artifact_type == "sarifs":
            file_path = task_dir / f"{artifact_id}.sarif"
        else:
            logger.error(f"Unknown artifact type: {artifact_type}")
            return False

        # Rename the file to mark it as deleted (append .deleted to the filename)
        deleted_path = file_path.with_suffix(file_path.suffix + ".deleted")
        file_path.rename(deleted_path)
        return True
    except Exception:
        logger.exception(f"Failed to get {artifact_type} artifact {artifact_id} for task {task_id}")
        return False


def save_bundle(task_id: str, bundle_id: str, content: dict) -> bool:
    """Save a bundle to the appropriate directory structure."""
    return save_artifact(task_id, "bundles", bundle_id, content)


def save_patch(task_id: str, patch_id: str, content: str) -> bool:
    """Save a patch to the appropriate directory structure."""
    return save_artifact(task_id, "patches", patch_id, content, True)


def save_pov(task_id: str, pov_id: str, content: str) -> bool:
    """Save a POV to the appropriate directory structure."""
    return save_artifact(task_id, "povs", pov_id, content, True)


def save_sarif(task_id: str, sarif_id: str, content: dict) -> bool:
    """Save a SARIF to the appropriate directory structure."""
    return save_artifact(task_id, "sarifs", sarif_id, content, True)


def get_bundle(task_id: str, bundle_id: str) -> dict | None:
    artifact = get_artifact(task_id, "bundles", bundle_id)
    if artifact is None:
        return None

    assert isinstance(artifact, dict)
    return artifact


def get_challenge_service() -> ChallengeService:
    """Get challenge service instance."""
    settings = get_settings()
    return ChallengeService(settings.storage_dir, f"http://{settings.external_host}:{settings.port}")


def get_crs_client() -> CRSClient:
    """Get CRS client instance."""
    settings = get_settings()
    return CRSClient(settings.crs_base_url, settings.crs_key_id, settings.crs_key_token)


# Mount static files
static_dir = Path(__file__).parent.parent / "static"
if static_dir.exists():
    app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")


# Utility functions for task management
def calculate_task_status(task: Task) -> str:
    """Calculate task status based on deadline and CRS submission status."""
    try:
        # First check if the task failed to submit to CRS
        crs_status = getattr(task, "crs_submission_status", None)
        if crs_status == "failed":
            return "failed"

        # Then check deadline
        deadline = getattr(task, "deadline", None)
        if deadline is None:
            return "active"  # Default to active if no deadline

        now = datetime.now(deadline.tzinfo) if deadline.tzinfo else datetime.now()
        if now > deadline:
            return "expired"

        return "active"
    except Exception:
        return "active"  # Default to active if parsing fails


def update_dashboard_stats(database_manager: DatabaseManager) -> None:
    """Update dashboard statistics from current tasks."""
    global dashboard_stats

    active_count = 0
    total_povs = 0
    total_patches = 0
    total_bundles = 0
    failed_tasks_count = 0
    with database_manager.get_all_tasks() as tasks:
        for task in tasks:
            task_status = calculate_task_status(task)
            if task_status == "active":
                active_count += 1
            if task_status == "failed":
                failed_tasks_count += 1

            total_povs += len(task.povs)
            total_patches += len(task.patches)
            total_bundles += len(task.bundles)

    dashboard_stats.update(
        {
            "activeTasks": active_count,
            "totalPovs": total_povs,
            "totalPatches": total_patches,
            "totalBundles": total_bundles,
            "failedTasks": failed_tasks_count,
        },
    )


def pov_to_pov_info(pov: POV) -> dict[str, Any]:
    try:
        return {
            "pov_id": getattr(pov, "pov_id", "unknown"),
            "timestamp": getattr(pov, "created_at", datetime.now()),
            "architecture": getattr(pov, "architecture", "unknown"),
            "engine": getattr(pov, "engine", "unknown"),
            "fuzzer_name": getattr(pov, "fuzzer_name", "unknown"),
            "sanitizer": getattr(pov, "sanitizer", "unknown"),
            "testcase": base64.b64encode(getattr(pov, "testcase", b"")),
        }
    except Exception as e:
        logger.error(f"Error converting POV to info: {e}")
        return {"pov_id": "error", "error": str(e)}


def patch_to_patch_info(patch: Patch) -> dict[str, Any]:
    try:
        return {
            "patch_id": getattr(patch, "patch_id", "unknown"),
            "timestamp": getattr(patch, "created_at", datetime.now()),
            "patch": base64.b64encode(getattr(patch, "patch", "").encode("utf-8", errors="ignore")),
        }
    except Exception as e:
        logger.error(f"Error converting patch to info: {e}")
        return {"patch_id": "error", "error": str(e)}


def bundle_to_bundle_info(bundle: Bundle) -> dict[str, Any]:
    try:
        return {
            "bundle_id": getattr(bundle, "bundle_id", "unknown"),
            "timestamp": getattr(bundle, "created_at", datetime.now()),
            "description": getattr(bundle, "description", ""),
            "broadcast_sarif_id": getattr(bundle, "broadcast_sarif_id", None),
            "freeform_id": getattr(bundle, "freeform_id", None),
            "patch_id": getattr(bundle, "patch_id", None),
            "pov_id": getattr(bundle, "pov_id", None),
            "submitted_sarif_id": getattr(bundle, "submitted_sarif_id", None),
        }
    except Exception as e:
        logger.error(f"Error converting bundle to info: {e}")
        return {"bundle_id": "error", "error": str(e)}


def task_to_task_info(task: Task) -> TaskInfo:
    """Convert a task to a TaskInfo object."""
    try:
        povs = []
        for pov in task.povs:
            povs.append(pov_to_pov_info(pov))

        patches = []
        for patch in task.patches:
            patches.append(patch_to_patch_info(patch))

        bundles = []
        for bundle in task.bundles:
            bundles.append(bundle_to_bundle_info(bundle))

        task_data = {
            "task_id": task.task_id,
            "name": getattr(task, "name", None),
            "project_name": getattr(task, "project_name", "Unknown"),
            "status": calculate_task_status(task),
            "duration": getattr(task, "duration", 0),
            "deadline": getattr(task, "deadline", datetime.now()).isoformat()
            if getattr(task, "deadline", None)
            else None,
            "challenge_repo_url": getattr(task, "challenge_repo_url", None),
            "challenge_repo_head_ref": getattr(task, "challenge_repo_head_ref", None),
            "challenge_repo_base_ref": getattr(task, "challenge_repo_base_ref", None),
            "fuzz_tooling_url": getattr(task, "fuzz_tooling_url", None),
            "fuzz_tooling_ref": getattr(task, "fuzz_tooling_ref", None),
            "created_at": getattr(task, "created_at", datetime.now()).isoformat()
            if getattr(task, "created_at", None)
            else None,
            "povs": povs,
            "patches": patches,
            "bundles": bundles,
            # CRS submission status and error information
            "crs_submission_status": getattr(task, "crs_submission_status", None),
            "crs_submission_error": getattr(task, "crs_submission_error", None),
            "crs_error_details": getattr(task, "crs_error_details", None),
            "crs_submission_timestamp": getattr(task, "crs_submission_timestamp", datetime.fromtimestamp(0)).isoformat()
            if getattr(task, "crs_submission_timestamp", None)
            else None,
        }

        return TaskInfo(**task_data)
    except Exception as e:
        logger.error(f"Error in task_to_task_info for task {getattr(task, 'task_id', 'unknown')}: {e}", exc_info=True)
        raise


def _create_task(
    challenge: Challenge,
    challenge_service: ChallengeService,
    crs_client: CRSClient,
    database_manager: DatabaseManager,
) -> Message | Error:
    try:
        # Create task for the challenge
        task = challenge_service.create_task_for_challenge(
            challenge_repo_url=challenge.challenge_repo_url,
            challenge_repo_ref=challenge.challenge_repo_head_ref,
            challenge_repo_base_ref=challenge.challenge_repo_base_ref,
            fuzz_tooling_url=challenge.fuzz_tooling_url,
            fuzz_tooling_ref=challenge.fuzz_tooling_ref,
            fuzz_tooling_project_name=challenge.fuzz_tooling_project_name,
            duration_secs=challenge.duration,
        )

        # Store task data in database
        task_id = task.tasks[0].task_id
        name = challenge.name or task_id
        now = datetime.now()
        deadline = now + timedelta(seconds=challenge.duration)

        # Always create the task in the database first
        logger.info(f"Creating task {task_id} in database for challenge {challenge.name}")
        database_manager.create_task(
            task_id=task_id,
            name=name,
            project_name=challenge.fuzz_tooling_project_name,
            status="active",
            duration=challenge.duration,
            deadline=deadline,
            challenge_repo_url=challenge.challenge_repo_url,
            challenge_repo_head_ref=challenge.challenge_repo_head_ref,
            challenge_repo_base_ref=challenge.challenge_repo_base_ref,
            fuzz_tooling_url=challenge.fuzz_tooling_url,
            fuzz_tooling_ref=challenge.fuzz_tooling_ref,
        )
        logger.info(f"Task {task_id} created successfully in database")

        # Send task to CRS via POST /v1/task endpoint
        logger.info(f"Submitting task {task_id} to CRS...")
        crs_response = crs_client.submit_task(task)

        # Update the task with CRS submission results
        if crs_response.success:
            logger.info(f"Task {task_id} submitted successfully to CRS")
            database_manager.update_task_crs_status(task_id=task_id, crs_submission_status="success")
            logger.info(f"Task {task_id} CRS status updated to 'success'")
            return Message(
                message=f"Task {task_id} created and submitted successfully to CRS for challenge {challenge.name}"
            )
        logger.error(f"Failed to submit task {task_id} to CRS")

        # Generate user-friendly error message
        error_message = crs_response.get_user_friendly_error_message("Failed to submit task to CRS")
        logger.error(f"Task {task_id} error message: {error_message}")

        # Update the task with error information
        logger.info(f"Updating task {task_id} CRS status to 'failed' with error details")
        database_manager.update_task_crs_status(
            task_id=task_id,
            crs_submission_status="failed",
            crs_submission_error=error_message,
            crs_error_details=crs_response.error_details,
        )
        logger.info(f"Task {task_id} CRS status updated to 'failed' with error details")

        # Verify the task was updated correctly
        with database_manager.get_task(task_id) as updated_task:
            if updated_task:
                logger.info(f"Verified task {task_id} in database:")
                logger.info(f"  - CRS status: {getattr(updated_task, 'crs_submission_status', 'N/A')}")
                logger.info(f"  - CRS error: {getattr(updated_task, 'crs_submission_error', 'N/A')}")
                logger.info(f"  - CRS error details: {getattr(updated_task, 'crs_error_details', 'N/A')}")
            else:
                logger.error(f"Task {task_id} not found in database after update!")

        # Return success message since the task was created, but include the CRS error
        return Message(
            message=f"Task {task_id} created but failed to submit to CRS. "
            f"Task is visible in the dashboard with error details. "
            f"Error: {error_message}",
            color="error",
        )

    except Exception as e:
        logger.error(f"Error creating task for challenge {challenge.name}: {e}")

        # Create a failed task in the database even when the challenge service fails
        try:
            # Generate a unique task ID for the failed task
            failed_task_id = str(uuid.uuid4())
            name = challenge.name or f"failed-{failed_task_id[:8]}"
            now = datetime.now()
            deadline = now + timedelta(seconds=challenge.duration)

            logger.info(f"Creating failed task {failed_task_id} in database for challenge {challenge.name}")
            database_manager.create_task(
                task_id=failed_task_id,
                name=name,
                project_name=challenge.fuzz_tooling_project_name,
                status="failed",
                duration=challenge.duration,
                deadline=deadline,
                challenge_repo_url=challenge.challenge_repo_url,
                challenge_repo_head_ref=challenge.challenge_repo_head_ref,
                challenge_repo_base_ref=challenge.challenge_repo_base_ref,
                fuzz_tooling_url=challenge.fuzz_tooling_url,
                fuzz_tooling_ref=challenge.fuzz_tooling_ref,
            )

            # Mark it as failed with the error details
            error_message = f"Failed to create task: {str(e)}"
            database_manager.update_task_crs_status(
                task_id=failed_task_id,
                crs_submission_status="failed",
                crs_submission_error=error_message,
                crs_error_details={"exception": str(e), "error_type": "challenge_service_failure"},
            )

            logger.info(f"Failed task {failed_task_id} created in database with error details")

            # Return a message indicating the task was created but failed
            return Message(
                message=f"Task {failed_task_id} created but failed during setup. "
                f"Task is visible in the dashboard with error details. "
                f"Error: {error_message}",
                color="error",
            )

        except Exception as db_error:
            logger.error(f"Failed to create failed task in database: {db_error}")
            # If we can't even create the failed task, return the original error
            return Error(message=f"Failed to create task: {str(e)}")


def _create_sarif_broadcast(
    body: dict[str, Any],
    challenge_service: ChallengeService,
    crs_client: CRSClient,
) -> Message | Error:
    """Create a SARIF Broadcast"""
    if "task_id" not in body:
        return Error(message="Task ID is required")
    task_id = body["task_id"]

    if "sarif" not in body:
        return Error(message="SARIF body is required")

    sarif = body["sarif"]
    broadcast = challenge_service.create_sarif_broadcast(task_id, sarif)

    crs_response = crs_client.submit_sarif_broadcast(broadcast)

    if crs_response.success:
        return Message(message=f"SARIF Broadcast for Task {task_id} created and submitted to CRS")
    # Use the helper method to generate user-friendly error message
    error_message = crs_response.get_user_friendly_error_message(
        f"Failed to submit SARIF Broadcast for Task {task_id} to CRS"
    )

    # Return a message with the error details for better user experience
    return Message(
        message=f"SARIF Broadcast for Task {task_id} created but failed to submit to CRS. Error: {error_message}",
        color="error",
    )


@app.get("/v1/ping/", response_model=PingResponse, tags=["ping"])
def get_v1_ping_() -> PingResponse:
    """Test authentication creds and network connectivity"""
    return PingResponse(status="pong")


@app.get("/v1/crs-ping/", tags=["ping"])
def get_v1_crs_ping_(crs_client: CRSClient = Depends(get_crs_client)) -> dict:
    """Test connectivity to CRS"""
    crs_ready = crs_client.ping()
    return {
        "crs_ready": crs_ready,
        "crs_base_url": crs_client.crs_base_url,
    }


# Dashboard endpoints
@app.get("/", response_class=HTMLResponse, tags=["dashboard"])
def get_dashboard() -> HTMLResponse:
    """Serve the main dashboard HTML page"""
    static_dir = Path(__file__).parent.parent / "static"
    html_file = static_dir / "index.html"

    if html_file.exists():
        return HTMLResponse(content=html_file.read_text(), status_code=200)
    return HTMLResponse(content="<h1>Dashboard not found</h1>", status_code=404)


@app.get("/v1/dashboard/stats", response_model=DashboardStats, tags=["dashboard"])
def get_dashboard_stats(database_manager: DatabaseManager = Depends(get_database_manager)) -> DashboardStats:
    """Get dashboard statistics"""
    update_dashboard_stats(database_manager)
    return DashboardStats(**dashboard_stats)


@app.get("/v1/dashboard/config", tags=["dashboard"])
def get_dashboard_config() -> dict:
    """Get dashboard configuration including instance ID"""
    return {
        "crs_instance_id": crs_instance_id,
    }


@app.get("/v1/dashboard/tasks", response_model=list[TaskInfo], tags=["dashboard"])
def get_dashboard_tasks(database_manager: DatabaseManager = Depends(get_database_manager)) -> list[TaskInfo]:
    """Get list of all tasks for dashboard"""
    update_dashboard_stats(database_manager)
    with database_manager.get_all_tasks() as tasks:
        tasks_list = []
        for task in tasks:
            tasks_list.append(task_to_task_info(task))

    # Sort by created_at descending (newest first)
    tasks_list.sort(key=lambda x: x.created_at, reverse=True)
    return tasks_list


@app.get("/v1/dashboard/tasks/failed", response_model=List[TaskInfo], tags=["dashboard"])
def get_failed_tasks(database_manager: DatabaseManager = Depends(get_database_manager)) -> List[TaskInfo]:
    """
    Get list of failed tasks for debugging
    """
    logger.info("get_failed_tasks endpoint called")

    try:
        failed_tasks = database_manager.get_tasks_by_crs_status("failed")
        logger.info(f"Found {len(failed_tasks)} failed tasks in database")

        if failed_tasks:
            logger.info(f"First failed task ID: {failed_tasks[0].task_id}")
            logger.info(f"First failed task CRS status: {getattr(failed_tasks[0], 'crs_submission_status', 'N/A')}")
            logger.info(f"First failed task CRS error: {getattr(failed_tasks[0], 'crs_submission_error', 'N/A')}")

        tasks_list = []
        for task in failed_tasks:
            try:
                task_info = task_to_task_info(task)
                tasks_list.append(task_info)
                logger.info(f"Converted task {task.task_id} to TaskInfo with status: {task_info.status}")
            except Exception as task_error:
                logger.error(f"Error converting task {task.task_id} to TaskInfo: {task_error}", exc_info=True)
                # Skip this task and continue with others
                continue

        # Sort by created_at descending (newest first)
        tasks_list.sort(key=lambda x: x.created_at, reverse=True)
        logger.info(f"Returning {len(tasks_list)} failed tasks")

        return tasks_list

    except Exception as e:
        logger.error(f"Error in get_failed_tasks: {e}", exc_info=True)
        raise


@app.get("/v1/dashboard/tasks/active", response_model=List[TaskInfo], tags=["dashboard"])
def get_active_tasks(database_manager: DatabaseManager = Depends(get_database_manager)) -> List[TaskInfo]:
    """
    Get list of active tasks
    """
    active_tasks = database_manager.get_tasks_by_status("active")
    tasks_list = []
    for task in active_tasks:
        tasks_list.append(task_to_task_info(task))

    # Sort by created_at descending (newest first)
    tasks_list.sort(key=lambda x: x.created_at, reverse=True)
    return tasks_list


@app.get("/v1/dashboard/tasks/expired", response_model=List[TaskInfo], tags=["dashboard"])
def get_expired_tasks(database_manager: DatabaseManager = Depends(get_database_manager)) -> List[TaskInfo]:
    """
    Get list of expired tasks
    """
    expired_tasks = database_manager.get_tasks_by_status("expired")
    tasks_list = []
    for task in expired_tasks:
        tasks_list.append(task_to_task_info(task))

    # Sort by created_at descending (newest first)
    tasks_list.sort(key=lambda x: x.created_at, reverse=True)
    return tasks_list


@app.get("/v1/dashboard/tasks/{task_id}", response_model=TaskInfo, tags=["dashboard"])
def get_dashboard_task(task_id: str, database_manager: DatabaseManager = Depends(get_database_manager)) -> TaskInfo:
    """Get detailed information about a specific task"""
    with database_manager.get_task(task_id) as task:
        if not task:
            raise HTTPException(status_code=404, detail="Task not found")

        return task_to_task_info(task)


@app.get("/v1/dashboard/tasks/{task_id}/crs-status", tags=["dashboard"])
def get_task_crs_status(task_id: str, database_manager: DatabaseManager = Depends(get_database_manager)) -> dict:
    """
    Get detailed CRS submission status and error information for a specific task
    """
    with database_manager.get_task(task_id) as task:
        if not task:
            raise HTTPException(status_code=404, detail="Task not found")

        import json

        # Parse error details if present
        error_details = None
        if hasattr(task, "crs_error_details") and task.crs_error_details:
            try:
                error_details = json.loads(task.crs_error_details)
            except json.JSONDecodeError:
                error_details = {"raw": task.crs_error_details}

        return {
            "task_id": task_id,
            "crs_submission_status": getattr(task, "crs_submission_status", None),
            "crs_submission_error": getattr(task, "crs_submission_error", None),
            "crs_error_details": error_details,
            "crs_submission_timestamp": getattr(task, "crs_submission_timestamp", datetime.fromtimestamp(0)).isoformat()
            if getattr(task, "crs_submission_timestamp", None)
            else None,
        }


@app.get(
    "/v1/request/list/",
    response_model=RequestListResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["request"],
)
def get_v1_request_list_() -> RequestListResponse | Error:
    """Get a list of available challenges to task"""
    return RequestListResponse(challenges=[c.name for c in challenges if c.name is not None])


@app.post(
    "/v1/request/{challenge_name}",
    response_model=Message,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["request"],
)
def post_v1_request_challenge_name(
    challenge_name: str,
    body: RequestSubmission,
    challenge_service: ChallengeService = Depends(get_challenge_service),
    crs_client: CRSClient = Depends(get_crs_client),
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> Message | Error:
    """Send a task to the source of this request"""
    if challenge_name not in [c.name for c in challenges]:
        return Error(message=f"Challenge {challenge_name} not found")

    # Find the challenge
    challenge = next(c for c in challenges if c.name == challenge_name)
    logger.info(f"Creating task for challenge {challenge_name}")

    # Get duration from request or use challenge default
    if body.duration_secs:
        challenge.duration = body.duration_secs

    return _create_task(challenge, challenge_service, crs_client, database_manager)


@app.post(
    "/v1/task/{task_id}/broadcast-sarif-assessment/{broadcast_sarif_id}/",
    response_model=SarifAssessmentResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["broadcast-sarif-assessment"],
)
def post_v1_task_task_id_broadcast_sarif_assessment_broadcast_sarif_id_(
    task_id: str,
    broadcast_sarif_id: str,
    body: SarifAssessmentSubmission,
) -> SarifAssessmentResponse | Error:
    """Submit a SARIF Assessment"""
    logger.info(
        f"SARIF Assessment submission - Task: {task_id}, Broadcast SARIF ID: {broadcast_sarif_id}, Assessment: {body.assessment}, Description: {body.description[:100]}...",
    )
    return SarifAssessmentResponse(status=SubmissionStatus.SubmissionStatusAccepted)


@app.post(
    "/v1/task/{task_id}/bundle/",
    response_model=BundleSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def post_v1_task_task_id_bundle_(
    task_id: str,
    body: BundleSubmission,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> BundleSubmissionResponse | Error:
    """Submit Bundle"""
    logger.info(f"Bundle submission - Task: {task_id}")
    logger.debug(f"Bundle details: {json.dumps(body.model_dump(), indent=2)}")

    bundle = database_manager.create_bundle(
        task_id=task_id,
        broadcast_sarif_id=body.broadcast_sarif_id,
        description=body.description,
        freeform_id=body.freeform_id,
        patch_id=body.patch_id,
        pov_id=body.pov_id,
        submitted_sarif_id=body.submitted_sarif_id,
    )

    save_bundle(task_id, bundle.bundle_id, body.model_dump())

    return BundleSubmissionResponse(bundle_id=bundle.bundle_id, status=SubmissionStatus.SubmissionStatusAccepted)


@app.get(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    response_model=BundleSubmissionResponseVerbose,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def get_v1_task_task_id_bundle_bundle_id_(
    task_id: str,
    bundle_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> BundleSubmissionResponseVerbose | Error:
    """Get Bundle"""
    logger.info(f"Bundle retrieval - Task: {task_id}, Bundle ID: {bundle_id}")
    with database_manager.get_bundle(bundle_id, task_id) as bundle:
        if bundle is None:
            return Error(message=f"Bundle {bundle_id} not found")

        return BundleSubmissionResponseVerbose(
            broadcast_sarif_id=bundle.broadcast_sarif_id,
            bundle_id=bundle_id,
            description=bundle.description,
            freeform_id=bundle.freeform_id,
            patch_id=bundle.patch_id,
            pov_id=bundle.pov_id,
            submitted_sarif_id=bundle.submitted_sarif_id,
            status=SubmissionStatus.SubmissionStatusAccepted,
        )


@app.delete(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    responses={
        "204": {},
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def delete_v1_task_task_id_bundle_bundle_id_(
    task_id: str,
    bundle_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> str | Error | None:
    """Delete Bundle"""
    logger.info(f"Bundle deletion - Task: {task_id}, Bundle ID: {bundle_id}")
    with database_manager.get_bundle(bundle_id, task_id) as bundle:
        if bundle is None:
            return Error(message=f"Bundle {bundle_id} not found")

        database_manager.delete_bundle(bundle)
        delete_artifact(task_id, "bundles", bundle_id)

    return None


@app.patch(
    "/v1/task/{task_id}/bundle/{bundle_id}/",
    response_model=BundleSubmissionResponseVerbose,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["bundle"],
)
def patch_v1_task_task_id_bundle_bundle_id_(
    task_id: str,
    bundle_id: str,
    body: BundleSubmission,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> BundleSubmissionResponseVerbose | Error:
    """Update Bundle"""
    logger.info(f"Bundle update - Task: {task_id}, Bundle ID: {bundle_id}")
    logger.info(f"Updated bundle details: {json.dumps(body.model_dump(), indent=2)}")

    with database_manager.get_bundle(bundle_id, task_id) as bundle:
        if bundle is None:
            return Error(message=f"Bundle {bundle_id} not found")

        bundle.broadcast_sarif_id = body.broadcast_sarif_id or bundle.broadcast_sarif_id
        bundle.description = body.description or bundle.description
        bundle.freeform_id = body.freeform_id or bundle.freeform_id
        bundle.patch_id = body.patch_id or bundle.patch_id
        bundle.pov_id = body.pov_id or bundle.pov_id
        bundle.submitted_sarif_id = body.submitted_sarif_id or bundle.submitted_sarif_id

        # Save bundle to disk (for backward compatibility)
        save_bundle(task_id, bundle_id, body.model_dump())

        return BundleSubmissionResponseVerbose(
            broadcast_sarif_id=bundle.broadcast_sarif_id,
            bundle_id=bundle_id,
            description=bundle.description,
            freeform_id=bundle.freeform_id,
            patch_id=bundle.patch_id,
            pov_id=bundle.pov_id,
            submitted_sarif_id=bundle.submitted_sarif_id,
            status=SubmissionStatus.SubmissionStatusAccepted,
        )


@app.post(
    "/v1/task/{task_id}/freeform/",
    response_model=FreeformResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["freeform"],
)
def post_v1_task_task_id_freeform_(task_id: str, body: FreeformSubmission) -> FreeformResponse | Error:
    """Submit Freeform"""
    freeform_id = str(uuid.uuid4())
    logger.info(f"Freeform submission - Task: {task_id}, Freeform ID: {freeform_id}")
    logger.info(f"Freeform submission size: {len(body.submission)} bytes")
    return Error(message="Not implemented")


@app.post(
    "/v1/task/{task_id}/patch/",
    response_model=PatchSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["patch"],
)
def post_v1_task_task_id_patch_(
    task_id: str,
    body: PatchSubmission,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> PatchSubmissionResponse | Error:
    """Submit Patch"""
    logger.info(f"Patch submission - Task: {task_id}")
    logger.debug(f"Patch details: {json.dumps(body.model_dump(), indent=2)}")

    patch = database_manager.create_patch(
        task_id=task_id,
        patch=base64.b64decode(body.patch).decode("utf-8", errors="ignore"),
    )
    save_patch(task_id, patch.patch_id, body.patch)

    return PatchSubmissionResponse(
        patch_id=patch.patch_id,
        status=SubmissionStatus.SubmissionStatusAccepted,
        functionality_tests_passing=None,
    )


@app.get(
    "/v1/task/{task_id}/patch/{patch_id}/",
    response_model=PatchSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["patch"],
)
def get_v1_task_task_id_patch_patch_id_(
    task_id: str,
    patch_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> PatchSubmissionResponse | Error:
    """Patch Status"""
    logger.info(f"Patch status check - Task: {task_id}, Patch ID: {patch_id}")
    with database_manager.get_patch(patch_id, task_id) as patch:
        if patch is None:
            return Error(message=f"Patch {patch_id} not found")

    return PatchSubmissionResponse(
        patch_id=patch_id,
        status=SubmissionStatus.SubmissionStatusPassed,
        functionality_tests_passing=True,
    )


@app.post(
    "/v1/task/{task_id}/pov/",
    response_model=POVSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["pov"],
)
def post_v1_task_task_id_pov_(
    task_id: str,
    body: POVSubmission,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> POVSubmissionResponse | Error:
    """Submit Vulnerability"""
    logger.info(f"POV submission - Task: {task_id}")
    logger.debug(
        f"POV details: architecture={body.architecture.value}, engine={body.engine.value}, fuzzer_name={body.fuzzer_name}, sanitizer={body.sanitizer}",
    )

    with database_manager.get_task(task_id) as task:
        if task is None:
            return Error(message=f"Task {task_id} not found")

    pov = database_manager.create_pov(
        task_id=task_id,
        architecture=body.architecture.value,
        engine=body.engine.value,
        fuzzer_name=body.fuzzer_name,
        sanitizer=body.sanitizer,
        testcase=base64.b64decode(body.testcase),
    )
    save_pov(task_id, pov.pov_id, body.testcase)

    return POVSubmissionResponse(pov_id=pov.pov_id, status=SubmissionStatus.SubmissionStatusAccepted)


@app.get(
    "/v1/task/{task_id}/pov/{pov_id}/",
    response_model=POVSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["pov"],
)
def get_v1_task_task_id_pov_pov_id_(
    task_id: str,
    pov_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> POVSubmissionResponse | Error:
    """Vulnerability Status"""
    logger.info(f"POV status check - Task: {task_id}, POV ID: {pov_id}")
    with database_manager.get_pov(pov_id, task_id) as pov:
        if pov is None:
            return Error(message=f"POV {pov_id} not found")

    return POVSubmissionResponse(pov_id=pov_id, status=SubmissionStatus.SubmissionStatusPassed)


@app.post(
    "/v1/task/{task_id}/submitted-sarif/",
    response_model=SARIFSubmissionResponse,
    responses={
        "400": {"model": Error},
        "401": {"model": Error},
        "404": {"model": Error},
        "500": {"model": Error},
    },
    tags=["submitted-sarif"],
)
def post_v1_task_task_id_submitted_sarif_(task_id: str, body: SARIFSubmission) -> SARIFSubmissionResponse | Error:
    """Submit a CRS generated SARIF"""
    submitted_sarif_id = str(uuid.uuid4())
    logger.info(f"SARIF submission - Task: {task_id}, Submitted SARIF ID: {submitted_sarif_id}")
    logger.info(f"SARIF content: {json.dumps(body.sarif, indent=2)}")

    save_sarif(task_id, submitted_sarif_id, body.sarif)

    return SARIFSubmissionResponse(
        submitted_sarif_id=submitted_sarif_id,
        status=SubmissionStatus.SubmissionStatusPassed,
    )


@app.get("/files/{tarball_name}.tar.gz", tags=["files"])
def get_tarball(
    tarball_name: str,
    challenge_service: ChallengeService = Depends(get_challenge_service),
) -> FileResponse:
    """Serve tarball files for CRS download"""
    try:
        return challenge_service.serve_tarball(tarball_name)
    except Exception as e:
        logger.error(f"Error serving tarball {tarball_name}: {e}")
        raise


@app.post("/webhook/trigger_task")
def trigger_task(
    body: Challenge,
    challenge_service: ChallengeService = Depends(get_challenge_service),
    crs_client: CRSClient = Depends(get_crs_client),
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> Message | Error:
    """Trigger a task"""
    logger.info(f"Triggering task: {body.model_dump()}")
    return _create_task(body, challenge_service, crs_client, database_manager)


@app.post("/webhook/sarif")
def trigger_sarif(
    body: dict[str, Any],
    challenge_service: ChallengeService = Depends(get_challenge_service),
    crs_client: CRSClient = Depends(get_crs_client),
) -> Message | Error:
    """Trigger a SARIF Broadcast"""
    logger.info(f"Triggering SARIF Broadcast: {json.dumps(body, indent=2)}")
    return _create_sarif_broadcast(body, challenge_service, crs_client)


# Download endpoints for PoVs, Patches, and Bundles
@app.get("/v1/dashboard/tasks/{task_id}/povs/{pov_id}/download", tags=["dashboard"])
def download_pov(
    task_id: str,
    pov_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> Response:
    """Download a PoV testcase"""
    with database_manager.get_pov(pov_id, task_id) as pov:
        if pov is None:
            raise HTTPException(status_code=404, detail="POV not found")

        return Response(
            content=pov.testcase,
            media_type="application/octet-stream",
            headers={"Content-Disposition": f"attachment; filename=pov_{pov_id}.bin"},
        )


@app.get("/v1/dashboard/tasks/{task_id}/patches/{patch_id}/download", tags=["dashboard"])
def download_patch(
    task_id: str,
    patch_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> Response:
    """Download a patch"""
    with database_manager.get_patch(patch_id, task_id) as patch:
        if patch is None:
            raise HTTPException(status_code=404, detail="Patch not found")

        return Response(
            content=patch.patch,
            media_type="text/plain",
            headers={"Content-Disposition": f"attachment; filename=patch_{patch_id}.patch"},
        )


@app.get("/v1/dashboard/tasks/{task_id}/bundles/{bundle_id}/download", tags=["dashboard"])
def download_bundle(
    task_id: str,
    bundle_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> Response:
    """Download a bundle as JSON"""
    with database_manager.get_bundle(bundle_id, task_id) as bundle:
        if bundle is None:
            raise HTTPException(status_code=404, detail="Bundle not found")

        # Convert bundle to dict format for JSON serialization
        bundle_dict = bundle_to_bundle_info(bundle)
        bundle_json = json.dumps(bundle_dict, indent=2)

    return Response(
        content=bundle_json,
        media_type="application/json",
        headers={"Content-Disposition": f"attachment; filename=bundle_{bundle_id}.json"},
    )


# Detail view endpoints
@app.get("/v1/dashboard/povs/{pov_id}", tags=["dashboard"])
def get_pov_detail(pov_id: str, database_manager: DatabaseManager = Depends(get_database_manager)) -> dict[str, Any]:
    """Get detailed information about a specific PoV"""
    with database_manager.get_pov(pov_id) as pov:
        if pov is None:
            raise HTTPException(status_code=404, detail="POV not found")

        pov_dict = pov_to_pov_info(pov)
        return {
            "task_id": pov.task_id,
            "task_name": pov.task.name or pov.task.project_name,
            "pov": pov_dict,
        }


@app.get("/v1/dashboard/patches/{patch_id}", tags=["dashboard"])
def get_patch_detail(
    patch_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> dict[str, Any]:
    """Get detailed information about a specific patch"""
    with database_manager.get_patch(patch_id) as patch:
        if patch is None:
            raise HTTPException(status_code=404, detail="Patch not found")

        patch_dict = patch_to_patch_info(patch)
        return {
            "task_id": patch.task_id,
            "task_name": patch.task.name or patch.task.project_name,
            "patch": patch_dict,
        }


@app.get("/v1/dashboard/bundles/{bundle_id}", tags=["dashboard"])
def get_bundle_detail(
    bundle_id: str,
    database_manager: DatabaseManager = Depends(get_database_manager),
) -> dict[str, Any]:
    """Get detailed information about a specific bundle"""
    with database_manager.get_bundle(bundle_id) as bundle:
        if bundle is None:
            raise HTTPException(status_code=404, detail="Bundle not found")

        bundle_dict = bundle_to_bundle_info(bundle)
        return {
            "task_id": bundle.task_id,
            "task_name": bundle.task.name or bundle.task.project_name,
            "bundle": bundle_dict,
        }


# List all PoVs and Patches across tasks
@app.get("/v1/dashboard/povs", tags=["dashboard"])
def get_all_povs(database_manager: DatabaseManager = Depends(get_database_manager)) -> list[dict[str, Any]]:
    """Get all PoVs across all tasks"""
    all_povs: list[dict[str, Any]] = []

    with database_manager.get_all_povs() as povs:
        for pov in povs:
            pov_dict = pov_to_pov_info(pov)
            all_povs.append(
                {
                    "task_id": pov.task_id,
                    "task_name": pov.task.name or pov.task.project_name,
                    "pov": pov_dict,
                },
            )

    all_povs.sort(key=lambda x: x["pov"].get("timestamp", ""), reverse=True)
    return all_povs


@app.get("/v1/dashboard/patches", tags=["dashboard"])
def get_all_patches(database_manager: DatabaseManager = Depends(get_database_manager)) -> list[dict[str, Any]]:
    """Get all patches across all tasks"""
    all_patches: list[dict[str, Any]] = []

    with database_manager.get_all_patches() as patches:
        for patch in patches:
            patch_dict = patch_to_patch_info(patch)
            all_patches.append(
                {
                    "task_id": patch.task_id,
                    "task_name": patch.task.name or patch.task.project_name,
                    "patch": patch_dict,
                },
            )

    # Sort by timestamp descending
    all_patches.sort(key=lambda x: x["patch"].get("timestamp", ""), reverse=True)
    return all_patches
